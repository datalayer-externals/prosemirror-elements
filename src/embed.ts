import OrderedMap from "orderedmap";
import type { NodeSpec, Schema } from "prosemirror-model";
import type { EditorState, Transaction } from "prosemirror-state";
import { buildCommands, defaultPredicate } from "./helpers";
import type { NodeViewPropValues } from "./nodeViews/helpers";
import { createPlugin } from "./plugin";
import type { EmbedProps, TEmbed } from "./types/Embed";

/**
 * Build an embed plugin with the given embed specs, along with the schema required
 * by those embeds, and a method to insert embeds into the document.
 */
export const buildEmbedPlugin = <
  Props extends EmbedProps<string>,
  Name extends string
>(
  embedSpec: Array<TEmbed<Props, Name>>,
  predicate = defaultPredicate
) => {
  const typeNames = embedSpec.map((_) => _.name);

  const insertEmbed = (
    type: Name,
    fields: Partial<NodeViewPropValues<Props>>
  ) => (
    state: EditorState,
    dispatch: (tr: Transaction<Schema>) => void
  ): void => {
    if (!typeNames.includes(type)) {
      throw new Error(
        `[prosemirror-embeds]: ${type} is not recognised. Only ${typeNames.join(
          ", "
        )} can be added`
      );
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- we cannot be sure the schema has been amended
    if (!(state.schema as Schema).nodes[type]) {
      throw new Error(
        `[prosemirror-embeds]: ${type} is not included in the state schema. Did you add the NodeSpec generated by this plugin to the schema?`
      );
    }
    const newNode = (state.schema as Schema).nodes[type].createAndFill({
      type,
      fields,
    });
    if (newNode) {
      dispatch(state.tr.replaceSelectionWith(newNode));
    } else {
      // This shouldn't happen, as the schema should always be able to fill
      // the node with correct children if we're not supplying content â€“
      // see https://prosemirror.net/docs/ref/#model.NodeType.createAndFill
      console.warn(`[prosemirror-embeds]: could not create node for ${type}`);
    }
  };

  const plugin = createPlugin(embedSpec, buildCommands(predicate));
  const nodeSpec = embedSpec
    .map((embed) => embed.nodeSpec)
    .reduce((acc, spec) => acc.append(spec), OrderedMap.from<NodeSpec>({}));

  return {
    insertEmbed,
    hasErrors: (state: EditorState) => plugin.getState(state).hasErrors,
    plugin,
    nodeSpec,
  };
};
